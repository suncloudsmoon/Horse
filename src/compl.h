// This file was automatically generated by the horse compiler
#ifndef compl_H_
#define compl_H_
#include "__DEF__.h"
#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>
#include "__DEF__.h"
#include "errno.h"
#include "stdarg.h"
#include "ctype.h"
#include "string.h"

#define AVG_STRING_SIZE 32
#define STRING_ALLOCATION_SIZE 5
#define LIST_MANAGER_ALLOC_SIZE 10
typedef enum {
ERRNO_EXCEPTION = 1,
NULL_POINTER_EXCEPTION = 2,
INDEX_OUT_OF_BOUNDS_EXCEPTION = 3
} exception;
typedef struct {
char *text;
size_t text_length;
size_t text_allocated_length;
} string_t;
typedef struct {
void **data;
size_t data_length;
size_t data_allocated_length;
} list_t;
typedef struct {
list_t *allLines; // List of all lines
list_t *cleanedLines;
list_t *parsedLines; // List of parsed lines
list_t *compiledLines;
list_t *definitions;
string_t *includeStatements;
list_t *classes; // list of class_t
string_t* directory;
FILE *inputFile;
num scope;
num currentClass; // index of the current class found in the list of classes
} compiler_t;
typedef struct {
string_t *name;
list_t *sourceDefinitions; // like #define f compl_f
list_t *classTypedef;
string_t *includeStatements;
list_t *definitions; // and definitions
list_t *prototypes; // function prototypes
list_t *restOfLines;
} class_t;
const char *doubleSlashComment = "//";
const char *functionIdentifier = "def";
const char *privateFunctionIdentifier = "private def";
const char *endIdentifier = "end";
const char *returnIdentifier = "return";
const char *forIdentifier = "for";
const char *toKeyword = "to";
const char *doKeyword = "do";
const char *thenKeyword = "then";
const char *ifIdentifier = "if"; // for now
const char *elseIfIdentifier = "or if";
const char *elseIdentifier = "or";
const char *whileIdentifier = "while";
const char *classIdentifier = "class";
const char *takeIdentifier = "take"; // like switch()
const char *importIdentifier = "import"; // add basics to imports
const char *numIdentifier = "num"; // num science = 5
const char *numDataType = "long long int";
const char *defFileName = "DEF";
/*
returns -1 if no stopSign was found
*/
 int main(int argc, char **argv) ;
 void compl_startCompiler(string_t *directory, string_t *inputFilename) ;
 compiler_t* compl_compiler_init(string_t* directory, FILE *inputFile) ;
 void compl_compiler_free(compiler_t *com) ;
 void compl_ignition(compiler_t *com) ;
 void compl_readAllLines(compiler_t *com) ;
static  bool compl_readLine(FILE *stream, string_t *line) ;
 void compl_parse(compiler_t *com) ;
static  list_t* compl_split(char delimiter, string_t *line) ;
static  bool compl_isSpecialCharacter(char alpha) ;
 class_t* compl_class_new(string_t *name, string_t *includeStatements) ;
 void compl_compile(compiler_t *com) ;
static  void compl_handleForLoop(string_t *line, string_t *dest) ;
static  void compl_handleFunction(string_t *contextLine, class_t *currentClass, compiler_t *com, string_t *dest) ;
static  void compl_handlePrivateFunction(string_t *contextLine, class_t *currentClass, compiler_t *com, string_t *dest) ;
static  void compl_addFunctionHeader(string_t *functionBody, compiler_t *com) ;
static  void compl_addSourceFunctionDefinition(string_t *functionName, compiler_t *com) ;
static  void compl_addDefinitionToHeader(string_t *definition, compiler_t *com) ;
 int compl_writeToFile(compiler_t *com) ;
static  void compl_writeToHeaderFile(string_t *fullHeaderPath, class_t *currentClass) ;
static  void compl_writeToSourceFile(string_t *fullSourcePath, class_t *currentClass) ;
 list_t* compl_list_init() ;
static  list_t* compl_custom_list_init(size_t mallocSize) ;
 void compl_list_add(void *item, list_t *list) ;
 void compl_list_remove(int index, list_t *list) ;
 void compl_list_complete_remove(void (*indivfree)(void*), int index, list_t *list) ;
 void compl_list_clear(list_t *list) ;
 bool compl_list_equals(void *destComp, int index, bool (*equalsComparator)(void*, void*), list_t *list) ;
 bool compl_list_contains(void *destComp, bool (*equalsComparator)(void*, void*), list_t *list) ;
 void compl_list_serialize(void (*indiv)(void*, FILE*), FILE *stream, list_t *list) ;
 list_t* compl_list_deserialize(void* (*indivreverse)(FILE*), FILE *stream) ;
 void compl_list_free(list_t *list) ;
 void compl_list_complete_free(void (*indivfree)(void*), list_t *list) ;
static  void compl_list_meminspector(size_t addNum, list_t *subject) ;
 string_t* compl_string_init() ;
static  string_t* compl_custom_string_init(size_t allocationSize) ;
 string_t* compl_string_copyvalueof(char *src) ;
 string_t* compl_string_copyvalueof_s(string_t *src) ;
 void compl_string_printf(string_t *dest, char *format, ...) ;
 void compl_string_append(string_t *dest, char *src) ;
 void compl_string_append_s(string_t *dest, string_t *src) ;
 void compl_string_appendchar(string_t *dest, char letter) ;
 bool compl_string_isempty(string_t *str) ;
 int compl_string_indexof_s(string_t *src, char *stopSign) ;
 string_t** compl_string_split(char delimiter, string_t *src) ;
 bool compl_string_equals(string_t *dest, const char *src) ;
 bool compl_string_equals_s(string_t *dest, string_t *src) ;
 bool compl_string_equalsignorecase(string_t *dest, const char *src) ;
 bool compl_string_equalsignorecase_s(string_t *dest, string_t *src) ;
 bool compl_string_startswith_s(string_t *src, string_t *search) ;
 bool compl_string_startswith(string_t *src, const char *search) ;
 string_t* compl_string_substring_s(int startIndex, int endIndex, string_t *src) ;
 void compl_string_tolowercase_s(string_t *dest) ;
 bool compl_string_serialize(string_t *src, FILE *stream) ;
 string_t* compl_string_deserialize(FILE *stream) ;
 void compl_string_reset(string_t *dest) ;
 void compl_string_free(void *dest) ;
static  void compl_string_meminspection(size_t addNum, string_t *subject) ;
 void compl_throw_exception(exception e, int lineNum, char *message, ...) ;
#endif
